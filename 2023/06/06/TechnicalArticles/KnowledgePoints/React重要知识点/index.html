<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>React重要知识点 | NobitaYuan</title><meta name="author" content="NobitaYuan"><meta name="copyright" content="NobitaYuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="React重要知识点汇总">
<meta property="og:type" content="article">
<meta property="og:title" content="React重要知识点">
<meta property="og:url" content="https://nobitayuan.github.io/2023/06/06/TechnicalArticles/KnowledgePoints/React%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="NobitaYuan">
<meta property="og:description" content="React重要知识点汇总">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-06-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-07T05:54:34.759Z">
<meta property="article:author" content="NobitaYuan">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/y_logo2.png"><link rel="canonical" href="https://nobitayuan.github.io/2023/06/06/TechnicalArticles/KnowledgePoints/React%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.17/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: NobitaYuan","link":"链接: ","source":"来源: NobitaYuan","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'React重要知识点',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-07 13:54:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><span id="fps"></span><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/y_logo6.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">163</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影音</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-message"></i><span> 关于</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fas fa-heart-pulse"></i><span> MyLove</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="NobitaYuan"><img class="site-icon" src="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/y_logo2.png"/><span class="site-name">NobitaYuan</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影音</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user"></i><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-message"></i><span> 关于</span></a></li><li><a class="site-page child" href="/love/"><i class="fa-fw fas fa-heart-pulse"></i><span> MyLove</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">React重要知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-05T16:00:00.000Z" title="发表于 2023-06-06 00:00:00">2023-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-07T05:54:34.759Z" title="更新于 2023-08-07 13:54:34">2023-08-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/">重要知识点汇总</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="React重要知识点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="React重要知识点"><a href="#React重要知识点" class="headerlink" title="React重要知识点"></a>React重要知识点</h1><p><img src="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/image-20230316090723110.png" alt="image-20230316090723110" title="前端知识体系"></p>
<h3 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h3><p>React 是一个用于构建用户界面的 JavaScript 库。它是由 Facebook 开发并开源的，目前被广泛应用于前端开发中。</p>
<p>React 的主要特点是使用组件化的方式来构建用户界面。通过将界面拆分成独立可重用的组件，开发者可以更轻松地管理复杂的 UI，提高代码的可维护性和重用性。React 采用了虚拟 DOM（Virtual DOM）的概念，通过diff算法来比较dom树的差异，高效地更新实际 DOM。这种方式避免了直接操作 DOM 的复杂性和低效性，提供了更快的渲染速度和更好的用户体验。</p>
<p>React 还提供了一套声明式的编程模型，开发者只需要关注组件的状态和属性，通过对状态和属性的变化做出响应来更新界面。React 通过自动处理界面的更新，使得开发者可以更专注于应用的逻辑和交互，而无需手动操作 DOM。</p>
<h3 id="vue和react的区别"><a href="#vue和react的区别" class="headerlink" title="vue和react的区别"></a>vue和react的区别</h3><p>vue是一门框架，react是一个库</p>
<p><strong>官方态度</strong></p>
<ul>
<li>vue的官方提供了一套完整的开发流程，以追求最佳实现，利用vuex进行全局状态管理，vue-router路由管理，scope进行css的管理</li>
<li>react则是灵活多变，官方更推崇用户去社区寻找实现方案，不管是全局状态管理还是路由管理，都需要到社区中寻找各种各样的方案</li>
</ul>
<p><strong>写法上</strong></p>
<ul>
<li>vue是编写template，写入vue文件，写法上接近于原生html（更符合W3C标准）</li>
<li>react则是编写jsx，写入js文件，写法上更加的灵活，（可在html里嵌套js的写法）</li>
</ul>
<p><strong>组件类型</strong></p>
<p>vue的组件有vue2的选项式组件写法，vue3的组合式写法</p>
<p>react则可以编写类组件和函数式组件</p>
<p><strong>语法上</strong></p>
<ul>
<li><p>vue推崇指令化编写，官方提供的大量的指令</p>
</li>
<li><p>react则推崇原生的js书写，语法上更加灵活</p>
</li>
</ul>
<h3 id="为什么要使用JSX，有什么特点"><a href="#为什么要使用JSX，有什么特点" class="headerlink" title="为什么要使用JSX，有什么特点"></a>为什么要使用JSX，有什么特点</h3><ul>
<li>可声明变量</li>
<li>可嵌入表达式</li>
<li>单标签可以提前闭合</li>
<li>类名和属性使用驼峰命名</li>
</ul>
<h3 id="react的生命周期"><a href="#react的生命周期" class="headerlink" title="react的生命周期"></a>react的生命周期</h3><p>当一个应用或者页面从创建到销毁的过程中，在某个过程会自动调用的函数被称作生命周期钩子函数</p>
<p><img src="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/1654490712545-6bd28fa7-290b-48fb-8d51-bbf5578dad3f.png"></p>
<p>constructor — render — componentDidMount — componentDidUpdate — componentWillUnmount</p>
<h3 id="如何进行组件间传值"><a href="#如何进行组件间传值" class="headerlink" title="如何进行组件间传值"></a>如何进行组件间传值</h3><ul>
<li>父传子</li>
</ul>
<p>父组件利用属性直接传值，子组件通过this.props[属性名]直接使用</p>
<ul>
<li>字传父</li>
</ul>
<p>父组件传入函数，子组件调用函数并传入函数，父组件即可在函数中接收到数据</p>
<ul>
<li>兄弟传值</li>
</ul>
<p>通过一个公共的父组件，一个兄弟组件通过调用父组件的函数，改变父元素的数据，而该数据会传递给另外一个兄弟组件，从而间接的完成了兄弟间组件传值</p>
<ul>
<li>跨组件传值（爷孙传值）</li>
</ul>
<p>使用 Provider 和 Consumer组件，利用Provider组件通过属性提供数据，利用Consumer组件通过函数接收数据</p>
<h3 id="什么是受控组件和非受控组件"><a href="#什么是受控组件和非受控组件" class="headerlink" title="什么是受控组件和非受控组件"></a>什么是受控组件和非受控组件</h3><p>​	组件中数据的变化会实时渲染到视图上，视图上数据的变化也会实时的更新到数据中，例如input框中的value和state中的数据的双向绑定</p>
<h3 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h3><p>官方的定义: 高阶组件是一个<code>参数为组件</code>，并且<code>返回值为新组件</code>的<code>函数</code>;</p>
<p>两个组件组合成一个新的组件，具有两个组件的优点</p>
<h3 id="什么是React的renderprops功能"><a href="#什么是React的renderprops功能" class="headerlink" title="什么是React的renderprops功能"></a>什么是React的renderprops功能</h3><p>​	父组件传入一个函数给子组件（函数体是要渲染的组件），要渲染的组件中的某些数据需要子组件提供，此时子组件接收到函数并调用，将参数传入，此时父组件通过函数的参数接收到了数据，便可以顺利的通过收到的数据渲染内容</p>
<h3 id="React为什么会出现Hooks"><a href="#React为什么会出现Hooks" class="headerlink" title="React为什么会出现Hooks"></a>React为什么会出现Hooks</h3><blockquote>
<p> react hooks引入于16.8</p>
</blockquote>
<ol>
<li>难以维护：由于 React 类组件代码逻辑分裂，因此它们可能变得难以维护。这可能会导致错误和性能问题。</li>
<li>高内存占用：React 类组件在渲染时需要创建很多实例，这会导致内存占用过高。如果应用程序中有大量的 React 类组件，则可能会导致内存泄漏和性能问题。</li>
<li>难以测试：由于 React 类组件通常是单例模式，因此它们很难进行单元测试。这意味着开发人员必须依赖于其他测试方法来验证其行为。</li>
<li>难以调试：由于 React 类组件通常具有复杂的状态管理，因此它们很难调试。这可能会导致错误和性能问题。</li>
<li>难以重用：由于 React 类组件是单例模式，因此它们很难被其他组件重用。这可能会导致代码重复和不必要的工作。</li>
<li>react类组件数据和函数距离过远不利于逻辑并和 类似于VUE2和VUE3关系</li>
</ol>
<h3 id="React的高阶组件、renderprops、hooks的区别"><a href="#React的高阶组件、renderprops、hooks的区别" class="headerlink" title="React的高阶组件、renderprops、hooks的区别"></a>React的高阶组件、renderprops、hooks的区别</h3><ul>
<li><p>三者都是用来扩展react组件的功能的工具</p>
</li>
<li><p>高阶组件是一种函数式编程的思想：高阶组件是一个<code>参数为组件</code>，并且<code>返回值为新组件</code>的<code>函数</code>;两个组件组合成一个新的组件，具有两个组件的优点</p>
</li>
<li><p>renderprops是React的一种特性，传入一个函数，函数的返回值是一个组件，子组件调用这个函数，返回这个组件</p>
</li>
<li><p>hooks是 React v16.8 新增的API，也被称为钩子函数，这系列的api提供了大量的增强函数组件的方法，例如添加响应式数据的useState，类似生命周期的响应钩子等，另外用户还可以自定义hooks</p>
</li>
</ul>
<h3 id="react-router-dom的路由跳转"><a href="#react-router-dom的路由跳转" class="headerlink" title="react-router-dom的路由跳转"></a>react-router-dom的路由跳转</h3><ul>
<li><p>v5版本，使用bwoserRouter包裹的第一层组件可以从props中直接获取match，history，location对象，从而进行相应的操作，但是孙级组件的props不会直接获得以上三个属性，需要使用withrouter的包裹，从而获得以上三个对象。</p>
</li>
<li><p>v6版本直接使用useNavigate()</p>
</li>
</ul>
<h3 id="对redux的特性"><a href="#对redux的特性" class="headerlink" title="对redux的特性"></a>对redux的特性</h3><p>状态管理工具</p>
<p>需要订阅</p>
<ul>
<li>actions</li>
<li>store</li>
<li>reducers</li>
</ul>
<p><img src="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5.jpeg"></p>
<h3 id="对MobX的理解"><a href="#对MobX的理解" class="headerlink" title="对MobX的理解"></a>对MobX的理解</h3><p>MobX 是一个用于管理 JavaScript 应用状态的库，它基于 Redux 的思想，提供了一种更加简单、易用的状态管理方式。</p>
<p>MobX 的核心概念是 Store,它是一个响应式的对象，可以自动跟踪应用程序中的状态变化，并将这些变化反映在应用程序的 UI 中。Store 中的每个属性都是一个观察者，当属性的值发生变化时，Store 会自动更新所有与该属性相关的组件。</p>
<p>MobX 还提供了一些工具和 API,例如 Action、Observable、connect 等，使得开发者可以轻松地创建和管理 Store,以及将 Store 与其他部分集成在一起。</p>
<p>相比于 Redux,MobX 提供了更加直观和简单的 API,使得开发者可以更加快速地构建出状态管理逻辑。同时，MobX 还提供了一些高级特性，例如中间件、异步操作等，使得开发者可以更加灵活地处理应用程序的状态变化。</p>
<p>总之，MobX 是一种非常强大的状态管理库，它可以帮助开发者更好地组织和管理应用程序的状态，从而提高应用程序的可维护性和可扩展性。</p>
<h3 id="对Redux-ToolKit的理解"><a href="#对Redux-ToolKit的理解" class="headerlink" title="对Redux ToolKit的理解"></a>对Redux ToolKit的理解</h3><p>ReduxToolkit 是一个基于 Redux 的 React 状态管理库，它提供了一些工具和 API,使得开发者可以更加方便地使用 Redux 来管理应用程序的状态。</p>
<p>ReduxToolkit 的主要功能包括：</p>
<ol>
<li>自动生成 connect 函数：ReduxToolkit 可以自动为每个组件生成 connect 函数，从而将组件与 Redux Store 连接起来。这样，开发者就不需要手动编写 connect 函数了。</li>
<li>提供高阶组件：ReduxToolkit 提供了一些高阶组件， 使得开发者可以更加方便地使用 Redux。</li>
<li>支持异步操作：ReduxToolkit 支持异步操作，可以在不阻塞主线程的情况下进行数据获取和更新操作。这样可以提高应用程序的性能和响应速度。</li>
<li>支持多个 Store:ReduxToolkit 支持同时存在多个 Redux Store,从而可以将不同的数据源集成到同一个应用程序中。</li>
</ol>
<p>总之，ReduxToolkit 为开发者提供了更加便捷和高效的 Redux 使用方式，可以帮助开发者更好地组织和管理应用程序的状态，从而提高应用程序的可维护性和可扩展性。</p>
<h3 id="Redux-mbox-ReduxToolkit三者的区别"><a href="#Redux-mbox-ReduxToolkit三者的区别" class="headerlink" title="Redux,mbox,ReduxToolkit三者的区别"></a>Redux,mbox,ReduxToolkit三者的区别</h3><p>Redux、mbox 和 Redux Toolkit 都是用于状态管理的工具，但它们在一些方面有一些区别。</p>
<ol>
<li>Redux: Redux 是一个可预测状态容器，用于 JavaScript 应用的状态管理。它是 Flux 架构的一种实现方式。Redux 的核心概念包括 store、action 和 reducer。Redux 使用单一的状态树（单一的 store）来管理整个应用的状态，并使用纯函数的 reducer 来处理状态的更新。Redux 需要开发者手动编写 action 和 reducer，并且需要处理大量的样板代码，例如定义 action 的类型常量和编写 switch-case 语句。</li>
<li>mbox: mbox 是一个简洁、轻量级的状态管理库，它借鉴了 Redux 的一些思想，但提供了更简单的 API 和更少的样板代码。mbox 的核心概念是 store 和 signal。store 是应用的状态容器，signal 是用于触发状态变更的对象。mbox 使用响应式的方式来管理状态，当 signal 触发时，会自动更新相关的状态。mbox 采用链式调用的方式定义状态和信号，使代码更具可读性和易于维护。</li>
<li>Redux Toolkit: Redux Toolkit 是一个官方推荐的 Redux 工具包，旨在简化 Redux 的使用和减少样板代码。它提供了一些实用的工具函数和约定，帮助开发者更轻松地编写 Redux 代码。Redux Toolkit 包含了一个称为 createSlice 的函数，用于生成包含 reducer 和 action 的模块化切片（slice），大大简化了编写 reducer 和 action 的过程。它还提供了一个 configureStore 函数，用于快速创建一个预配置的 Redux store。此外，Redux Toolkit 还集成了 immer 库，使得在 reducer 中进行不可变更新变得更加简单。</li>
</ol>
<p>总结来说：</p>
<ul>
<li>Redux 是一个功能强大的状态管理库，但需要开发者手动编写大量的样板代码。</li>
<li>mbox 是一个简洁轻量的状态管理库，提供了响应式的状态管理和链式调用的 API。</li>
<li>Redux Toolkit 是一个简化 Redux 的工具包，提供了更简单的 API 和约定，减少样板代码的编写。</li>
</ul>
<p>选择使用哪个工具取决于个人和项目的需求，以及开发团队的偏好和经验。Redux 在大型应用和复杂状态管理方面表现良好，mbox 则更适合小型应用或希望更简单状态管理的场景，而 Redux Toolkit 则可以提供更方便和一致的开发体验。</p>
<ul>
<li>Redux需要订阅</li>
<li>mobx需要包裹组件</li>
<li>RTK类似于hooks的使用方式</li>
</ul>
<h3 id="React-Fiber是什么？"><a href="#React-Fiber是什么？" class="headerlink" title="React Fiber是什么？"></a>React Fiber是什么？</h3><ul>
<li>React Fiber 是 React 16 中引入的一种新的协调机制（reconciliation algorithm），是对核心算法的重写和重新实现。</li>
</ul>
<h3 id="React事件和HTML事件的区别"><a href="#React事件和HTML事件的区别" class="headerlink" title="React事件和HTML事件的区别"></a>React事件和HTML事件的区别</h3><ol>
<li>事件命名方式：在HTML中，事件名称是以”on”开头，例如”onclick”、”onchange”等。而在React中，事件名称采用驼峰命名法，例如”onClick”、”onChange”等。</li>
<li>事件绑定方式：在HTML中，可以通过在HTML元素上添加属性来绑定事件，例如<code>&lt;button onclick=&quot;handleClick()&quot;&gt;Click me&lt;/button&gt;</code>。而在React中，可以使用JSX语法来绑定事件，例如<code>&lt;button onClick=&#123;handleClick&#125;&gt;Click me&lt;/button&gt;</code>。</li>
<li>事件对象传递：在HTML中，事件处理函数可以通过<code>event</code>参数来访问事件对象，其中包含有关事件的详细信息。而在React中，事件处理函数的参数不是原始的事件对象，而是React合成事件（SyntheticEvent）对象，它是对原生事件的封装，提供了跨浏览器一致性和额外的功能。</li>
<li>事件冒泡和默认行为：在HTML中，事件冒泡和默认行为是自动处理的。而在React中，默认情况下，事件不会冒泡，也不会触发元素的默认行为。如果需要实现冒泡或取消默认行为，可以显式地调用相应的方法。</li>
<li>React 事件处理程序必须考虑异步操作和副作用。例如，如果一个事件处理程序执行了一个异步操作并返回一个Promise,那么它必须使用 useEffect 钩子来确保该 Promise 在组件卸载时被正确地处理。</li>
</ol>
<h3 id="React声明组件的方式"><a href="#React声明组件的方式" class="headerlink" title="React声明组件的方式"></a>React声明组件的方式</h3><ul>
<li>function</li>
<li>箭头函数</li>
<li>高阶组件</li>
<li>ES6的class类继承React.Component</li>
<li>ES5的createClass声明方式</li>
</ul>
<h3 id="类组件和函数组件的区别"><a href="#类组件和函数组件的区别" class="headerlink" title="类组件和函数组件的区别"></a>类组件和函数组件的区别</h3><ul>
<li>类组件有生命周期</li>
<li>类组件的使用需要被new</li>
<li>类组件使用数据需要通过this.props或者this.state</li>
<li>函数式组件捕获了渲染所使用的值。类组件会因为this的改变而失去原来的的值</li>
<li>类组件逻辑分裂</li>
</ul>
<blockquote>
<p><strong>未来的发展趋势</strong></p>
<p>由于 React Hooks 的诞生，现在 函数组件成了React 社区主推的方案</p>
<p>React 团队从 Facebook的实际业务场景触发，通过探索时间切片和并发模式，以及考虑性能的进一步优化和组件间更合理的代码拆分后，认为 <strong>类组件的模式并不能很好地适应未来的趋势</strong>，它们给出了以下3个原因：</p>
<ol>
<li>this 的模糊性</li>
<li>业务逻辑耦合在生命周期中</li>
<li>React 的组件代码缺乏标准的拆分方式</li>
</ol>
<p>而使用 Hooks 的函数组件可以提供比原先更细粒度的逻辑组织和复用，且能更好的适用于时间切片和并发模式</p>
</blockquote>
<h3 id="React中Component和PureComponent的区别"><a href="#React中Component和PureComponent的区别" class="headerlink" title="React中Component和PureComponent的区别"></a>React中Component和PureComponent的区别</h3><ul>
<li>PureComponent是继承自Component的子类，会自动加载shouldComponentUpdate函数</li>
<li>当组件需要更新的时候会自动调用shouldComponentUpdate函数对props和state进行浅比较</li>
<li>如果没有变化，则不会触发render函数的渲染</li>
</ul>
<h3 id="那些情况会触发React组件的重新渲染？"><a href="#那些情况会触发React组件的重新渲染？" class="headerlink" title="那些情况会触发React组件的重新渲染？"></a>那些情况会触发React组件的重新渲染？</h3><ul>
<li><p>props，state等数据的变化</p>
</li>
<li><p>类组件中的setState()</p>
</li>
<li><p>函数组件中的useState钩子里的set函数</p>
</li>
<li><p>组件的key值发生了变化</p>
</li>
<li><p>组件的 shouldComponentUpdate 方法返回值为 false,表示当前的 props 或 state 没有发生变化，不需要重新渲染</p>
</li>
</ul>
<h3 id="React如何判断何时重新渲染组件？"><a href="#React如何判断何时重新渲染组件？" class="headerlink" title="React如何判断何时重新渲染组件？"></a>React如何判断何时重新渲染组件？</h3><ul>
<li>使用 shouldComponentUpdate 方法，该方法中根据当前 props 和 state 的变化情况来决定是否需要重新渲染组件。如果返回值为 false,则表示不需要重新渲染；如果返回值为 true,则表示需要重新渲染。</li>
<li>使用 useEffect 钩子函数，可以用于在组件挂载、更新或卸载时执行一些操作。如果在 useEffect 中改变了组件的状态或者触发了事件，那么 React 会认为组件需要重新渲染。</li>
</ul>
<h3 id="React的render函数做了什么？"><a href="#React的render函数做了什么？" class="headerlink" title="React的render函数做了什么？"></a>React的render函数做了什么？</h3><p>React 的 render 函数是组件渲染的核心方法，每一个组件都有自己的render函数，它的作用是将组件的状态和属性的虚拟DOM转换成真实 HTML 元素，渲染到页面上。</p>
<ul>
<li>收集数据：获取props、state，对数据进行处理</li>
<li>生成HTML元素：生成html元素，同时将数据也添加其中，最后渲染到页面上</li>
<li>添加事件监听：为需要添加事件的元素添加事件的监听</li>
</ul>
<h3 id="有状态组件和无状态组件的区别和使用场景"><a href="#有状态组件和无状态组件的区别和使用场景" class="headerlink" title="有状态组件和无状态组件的区别和使用场景"></a>有状态组件和无状态组件的区别和使用场景</h3><p>1、有状态组件指的是可以拥有自己的状态(state)的组件</p>
<p> <strong>场景包括：</strong></p>
<ul>
<li>需要在组件内部保存一些数据的场景，例如表单组件、评论组件等；</li>
<li>需要在组件内部处理一些复杂的逻辑的场景，例如图表组件、表格组件等；</li>
<li>需要在多个子组件之间共享数据的场景，例如路由组件、应用程序入口组件等。</li>
</ul>
<p>2、无状态组件指的是不能拥有自己状态的组件。通常情况下，无状态组件只接受 props 作为输入，并将这些 props 渲染到页面上。</p>
<p> <strong>场景包括：</strong></p>
<ul>
<li>只要求展示数据的场景，例如图标、按钮、标签等；</li>
<li>需要在多个组件之间共享数据的场景，例如导航栏、页脚等；</li>
<li>需要复用相同结构的组件的场景，例如列表、表格等。</li>
</ul>
<h3 id="什么是受控组件和非受控组件-1"><a href="#什么是受控组件和非受控组件-1" class="headerlink" title="什么是受控组件和非受控组件"></a>什么是受控组件和非受控组件</h3><p>​	受控组件：组件中数据的变化会实时渲染到视图上，视图上数据的变化也会实时的更新到数据中，例如input框中的value和state中的数据的双向绑定</p>
<p>​	非受控组件：包括 div、span 等普通元素，以及 Link、Button 等需要用户交互才能更新状态的组件</p>
<h3 id="React-Fragment是什么？"><a href="#React-Fragment是什么？" class="headerlink" title="React Fragment是什么？"></a>React Fragment是什么？</h3><p>React Fragment 是 React 中一种特殊的组件</p>
<p>可以作为React组件的根组件使用，同时这个组件也不会渲染出来，可以减少不必要的性能开销</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法一：</span></span><br><span class="line">&lt;<span class="title class_">React</span>.<span class="property">Fragment</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">React</span>.<span class="property">Fragment</span>&gt;</span><br><span class="line"><span class="comment">//写法二：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br></pre></td></tr></table></figure>



<h3 id="React如何获取dom"><a href="#React如何获取dom" class="headerlink" title="React如何获取dom"></a>React如何获取dom</h3><ul>
<li>useRef</li>
<li>原生的document的dom选择器</li>
<li>利用hooks</li>
</ul>
<h3 id="React类组件中绑定this的方式有哪些？"><a href="#React类组件中绑定this的方式有哪些？" class="headerlink" title="React类组件中绑定this的方式有哪些？"></a>React类组件中绑定this的方式有哪些？</h3><ul>
<li><p>在构造函数内部使用bind绑定this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span> (props) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">message</span>: <span class="string">&#x27;Allo!&#x27;</span>&#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在render函数中用bind</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> <span class="attr">this.handleClick.bind</span>(<span class="attr">this</span>, &#x27;<span class="attr">赵四</span>&#x27;) &#125;&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在render函数中使用箭头函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>&#123; this.handleClick() &#125; &#125;&gt;Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="React类组件中的setState是同步的还是异步的"><a href="#React类组件中的setState是同步的还是异步的" class="headerlink" title="React类组件中的setState是同步的还是异步的"></a>React类组件中的setState是同步的还是异步的</h3><p>是异步的，setState() 方法并不会立即更新组件的状态，而是将更新后的 state 放入一个队列中，等待下一次渲染时再执行。</p>
<h3 id="React类组件中的setState第二个参数做什么的"><a href="#React类组件中的setState第二个参数做什么的" class="headerlink" title="React类组件中的setState第二个参数做什么的"></a>React类组件中的setState第二个参数做什么的</h3><p>第二个参数是state数据更新完成后的自动调用的回调函数</p>
<h3 id="React组件通信的方式"><a href="#React组件通信的方式" class="headerlink" title="React组件通信的方式"></a>React组件通信的方式</h3><p>在 React 中，常见的组件通信方式有以下几种：</p>
<ol>
<li><p>Props：父组件通过 props 将数据传递给子组件。子组件可以通过 props 属性来访问这些数据，并在需要时进行使用。</p>
</li>
<li><p>Context：React 提供了上下文(Context) API,可以让父组件向子组件传递数据。这种方式可以避免在父子组件之间多层嵌套传递数据的麻烦。</p>
</li>
<li><p>Callback 回调函数:父组件可以将一个回调函数作为 prop 传递给子组件，子组件可以在特定事件发生时调用该回调函数，从而将信息传递回父组件。</p>
</li>
<li><p>Redux &#x2F; MobX &#x2F; RTK：状态管理库，可以用于管理 React 应用中的全局状态。通过将应用的状态存储在一个中央仓库中，不同的组件可以共享这些状态，从而实现组件之间的通信。</p>
</li>
<li><p>React Router：React Router 是 React 官方提供的路由库，可以用于管理单页应用(SPA)中的路由。通过在路由配置中定义不同的组件，可以在不同的路由路径下渲染不同的组件，从而实现组件之间的通信。</p>
</li>
</ol>
<h3 id="React-Router的路由底层实现"><a href="#React-Router的路由底层实现" class="headerlink" title="React Router的路由底层实现"></a>React Router的路由底层实现</h3><p>H5新增的 History API</p>
<ul>
<li>hash 底层 原生方法  location.hash &#x3D; xxx </li>
<li>histroy底层  history.pushState、replaceState、history.go()</li>
</ul>
<h3 id="React中Link标签和a标签的区别"><a href="#React中Link标签和a标签的区别" class="headerlink" title="React中Link标签和a标签的区别"></a>React中Link标签和a标签的区别</h3><ul>
<li>类别：Link标签是React Router提供的组件，a标签则是html原生的标签</li>
<li>功能：Link 标签可以支持重定向、刷新、历史记录等，a标签只能进行页面跳转</li>
<li>传参：Link 标签可以通过 to 属性来指定跳转的目标地址，同时还可以通过 params、query、hash、action 等属性来传递参数。而 a 标签不能</li>
</ul>
<h3 id="如何解决props嵌套过深问题"><a href="#如何解决props嵌套过深问题" class="headerlink" title="如何解决props嵌套过深问题"></a>如何解决props嵌套过深问题</h3><ol>
<li>利用context跨组件传值</li>
<li>使用全局状态管理工具 Redux MobX RTK等</li>
</ol>
<h3 id="为什么useState要使用数组不是对象"><a href="#为什么useState要使用数组不是对象" class="headerlink" title="为什么useState要使用数组不是对象"></a>为什么useState要使用数组不是对象</h3><ol>
<li>可变性：数组是可变的数据结构，可以直接在运行时修改其内容，而对象是不可变的。这种可变性使得在 React 组件中更新状态时更加高效，因为可以直接修改数组中的值而无需创建新的对象。这样可以避免触发不必要的重新渲染，并提高性能。</li>
<li>索引访问：通过索引，可以快速访问和修改数组中特定位置的元素。而对象需要使用键来访问其属性，这可能需要更多的代码和处理。所以，使用数组作为状态可以提供更方便的索引访问。</li>
<li>兼容性：早期版本的 React 在状态传递时只对数组进行了浅拷贝，而不是对象。这意味着如果状态是对象，它会在组件之间共享同一个引用，可能会导致状态不同步的问题。但是，从 React 16.8 版本开始，引入了 Hooks，包括 <code>useState</code>，React 在内部会执行浅拷贝，以确保状态的独立性，无论是数组还是对象。</li>
</ol>
<h3 id="useEffect和useLayoutEffect的区别"><a href="#useEffect和useLayoutEffect的区别" class="headerlink" title="useEffect和useLayoutEffect的区别"></a>useEffect和useLayoutEffect的区别</h3><p>useEffect 和 useLayoutEffect 都是 React Hooks 提供的状态更新的钩子函数。</p>
<p><strong>useEffect</strong></p>
<p>是在组件渲染完成之后，即组件已经渲染到屏幕上后触发。</p>
<p><strong>useLayoutEffect</strong></p>
<p>在浏览器完成布局和绘制但尚未呈现到屏幕上时触发，它会在所有 DOM 变更完成后同步执行，阻塞页面渲染。</p>
<blockquote>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 是同步执行的，如果在其中进行耗时操作或阻塞浏览器渲染，可能会导致性能问题或页面卡顿。因此，一般情况下应优先考虑使用 <code>useEffect</code>，只有在确实需要在组件渲染后立即执行 DOM 操作或获取布局信息时才使用 <code>useLayoutEffect</code>。</p>
</blockquote>
<h3 id="用TS结合React项目写过吗说一下都用在哪里"><a href="#用TS结合React项目写过吗说一下都用在哪里" class="headerlink" title="用TS结合React项目写过吗说一下都用在哪里"></a>用TS结合React项目写过吗说一下都用在哪里</h3><ul>
<li>定义React组件时，使用FC限制组件类型</li>
<li>限制props的参数传递类型</li>
<li>在调用axios接口的时候，限制接口的参数传递的类型</li>
<li>使用antd组件的Table.Colum时候为render函数传递数据源进行类型限制</li>
</ul>
<h3 id="React的设计思路是什么"><a href="#React的设计思路是什么" class="headerlink" title="React的设计思路是什么"></a>React的设计思路是什么</h3><ul>
<li>组件化开发：整个应用程序看作是由多个组件组成的，每个组件都有自己的状态和行为</li>
<li>虚拟 DOM：React 通过使用虚拟 DOM(Virtual DOM)来提高渲染性能。</li>
<li>JSX：React 使用 JSX 来描述 UI 元素，JSX 语法类似于 HTML,但是可以嵌套表达式和函数调用。</li>
<li>单项数据流：React 采用单向数据流的设计思想，即从父组件到子组件的数据传递只能是单向的。</li>
</ul>
<h3 id="React如何实现v-show"><a href="#React如何实现v-show" class="headerlink" title="React如何实现v-show"></a>React如何实现v-show</h3><p>父子传参，传递一个控制显隐的属性，子组件根据这个参数的值，来判断是否添加display:none属性来控制显隐，从而实现的v-show的功能</p>
<h3 id="React遍历数据渲染的方法有哪些？"><a href="#React遍历数据渲染的方法有哪些？" class="headerlink" title="React遍历数据渲染的方法有哪些？"></a>React遍历数据渲染的方法有哪些？</h3><ul>
<li>Array.map()</li>
<li>Array.forEach()</li>
<li>也可以使用for循环，但是需要将数据存入数组，将数组渲染到页面</li>
</ul>
<h3 id="React错误边界"><a href="#React错误边界" class="headerlink" title="React错误边界"></a>React错误边界</h3><p>使用getDerivedStateFromError生命周期函数去捕获错误</p>
<h3 id="使用过那些React-hooks？"><a href="#使用过那些React-hooks？" class="headerlink" title="使用过那些React hooks？"></a>使用过那些React hooks？</h3><h4 id="数据相关hooks"><a href="#数据相关hooks" class="headerlink" title="数据相关hooks"></a>数据相关hooks</h4><h5 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h5><p>定义响应式数据</p>
<h5 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h5><p>可以帮助我们跨越组件层级直接传递变量，实现数据共享</p>
<p>Provider提供， Consumer获取</p>
<h5 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h5><p>计算属性</p>
<h5 id="useFef"><a href="#useFef" class="headerlink" title="useFef"></a>useFef</h5><p>用于获取组件或者dom对象</p>
<h5 id="useId"><a href="#useId" class="headerlink" title="useId"></a>useId</h5><p>用于在 React 组件中生成唯一标识符（ID）的自定义钩子函数。</p>
<h4 id="路由相关hooks"><a href="#路由相关hooks" class="headerlink" title="路由相关hooks"></a>路由相关hooks</h4><h5 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h5><p>可以解构获取当前跳转好的路由地址</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; pathname &#125; = <span class="title function_">useLocation</span>(); <span class="comment">// 获取请求路径</span></span><br></pre></td></tr></table></figure>

<h5 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h5><p>路由跳转的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">navigate</span>(<span class="string">&quot;/home&quot;</span>, &#123; <span class="attr">replace</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h5><p>获得路由跳转传过来的参数</p>
<p><strong>例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跳转+传参</span></span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&#x27;/detail/&#x27;</span>+item.<span class="property">proid</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受并解构参数</span></span><br><span class="line"><span class="keyword">const</span> &#123;proid&#125; = <span class="title function_">useParams</span>()</span><br></pre></td></tr></table></figure>

<h4 id="状态相关钩子hooks"><a href="#状态相关钩子hooks" class="headerlink" title="状态相关钩子hooks"></a>状态相关钩子hooks</h4><h5 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h5><p>是在组件渲染之后执行的钩子函数，用于处理异步操作、订阅事件、操作 DOM 等副作用。（是异步的）</p>
<h5 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h5><p> 在组件渲染之后、DOM 更新之前同步执行。</p>
<blockquote>
<p>需要注意的是，由于 <code>useLayoutEffect</code> 是同步执行的，如果在其中进行耗时操作或阻塞浏览器渲染，可能会导致性能问题或页面卡顿。因此，一般情况下应优先考虑使用 <code>useEffect</code>，只有在确实需要在组件渲染后立即执行 DOM 操作或获取布局信息时才使用 <code>useLayoutEffect</code>。</p>
</blockquote>
<h5 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h5><p>缓存函数</p>
<p>当依赖的数据变化时，会调用其中的回调函数</p>
<h5 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h5><p>主要作用就是获取Redux更新state</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="useTransition"><a href="#useTransition" class="headerlink" title="useTransition"></a>useTransition</h5><p>用于在并发模式下处理异步更新的过渡效果。</p>
<h5 id="createPortal"><a href="#createPortal" class="headerlink" title="createPortal"></a>createPortal</h5><p>传送门钩子</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://nobitayuan.github.io">NobitaYuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nobitayuan.github.io/2023/06/06/TechnicalArticles/KnowledgePoints/React%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/">https://nobitayuan.github.io/2023/06/06/TechnicalArticles/KnowledgePoints/React%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nobitayuan.github.io" target="_blank">NobitaYuan</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react/">react</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/06/TechnicalArticles/js/04.%E5%87%BD%E6%95%B0/" title="函数"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">函数</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/06/TechnicalArticles/KnowledgePoints/JS%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/" title="JS重要知识点"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS重要知识点</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://rvt7oeuw4.hn-bkt.clouddn.com/blog/y_logo6.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">NobitaYuan</div><div class="author-info__description">记性不好？那就记录下来！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">60</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">163</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/NobitaYuan"><i class="fab fa-github"></i><span>前往小窝...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/NobitaYuan" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://bilibili.com" target="_blank" title="bilibili"><i class="fab fa-bilibili"></i></a><a class="social-icon" href="https://www.zhihu.com" target="_blank" title="zhihu"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="mailto:nobitayuan@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">是不是感觉名字不好记呀？ 来跟我读：(诺比塔 袁) 这下不就记住了吗？</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">React重要知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact"><span class="toc-number">1.0.1.</span> <span class="toc-text">什么是React</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue%E5%92%8Creact%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.</span> <span class="toc-text">vue和react的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8JSX%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.0.3.</span> <span class="toc-text">为什么要使用JSX，有什么特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.4.</span> <span class="toc-text">react的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC"><span class="toc-number">1.0.5.</span> <span class="toc-text">如何进行组件间传值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.6.</span> <span class="toc-text">什么是受控组件和非受控组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">1.0.7.</span> <span class="toc-text">什么是高阶组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFReact%E7%9A%84renderprops%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.8.</span> <span class="toc-text">什么是React的renderprops功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0Hooks"><span class="toc-number">1.0.9.</span> <span class="toc-text">React为什么会出现Hooks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E3%80%81renderprops%E3%80%81hooks%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.10.</span> <span class="toc-text">React的高阶组件、renderprops、hooks的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-router-dom%E7%9A%84%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.0.11.</span> <span class="toc-text">react-router-dom的路由跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9redux%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.12.</span> <span class="toc-text">对redux的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9MobX%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.13.</span> <span class="toc-text">对MobX的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9Redux-ToolKit%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.14.</span> <span class="toc-text">对Redux ToolKit的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux-mbox-ReduxToolkit%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.15.</span> <span class="toc-text">Redux,mbox,ReduxToolkit三者的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Fiber%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.16.</span> <span class="toc-text">React Fiber是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%BA%8B%E4%BB%B6%E5%92%8CHTML%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.17.</span> <span class="toc-text">React事件和HTML事件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E5%A3%B0%E6%98%8E%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.18.</span> <span class="toc-text">React声明组件的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.19.</span> <span class="toc-text">类组件和函数组件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%B8%ADComponent%E5%92%8CPureComponent%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.20.</span> <span class="toc-text">React中Component和PureComponent的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E8%A7%A6%E5%8F%91React%E7%BB%84%E4%BB%B6%E7%9A%84%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">1.0.21.</span> <span class="toc-text">那些情况会触发React组件的重新渲染？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%BD%95%E6%97%B6%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.0.22.</span> <span class="toc-text">React如何判断何时重新渲染组件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%9A%84render%E5%87%BD%E6%95%B0%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.23.</span> <span class="toc-text">React的render函数做了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.24.</span> <span class="toc-text">有状态组件和无状态组件的区别和使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-1"><span class="toc-number">1.0.25.</span> <span class="toc-text">什么是受控组件和非受控组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Fragment%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.26.</span> <span class="toc-text">React Fragment是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96dom"><span class="toc-number">1.0.27.</span> <span class="toc-text">React如何获取dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.28.</span> <span class="toc-text">React类组件中绑定this的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84setState%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84"><span class="toc-number">1.0.29.</span> <span class="toc-text">React类组件中的setState是同步的还是异步的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%B1%BB%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84setState%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">1.0.30.</span> <span class="toc-text">React类组件中的setState第二个参数做什么的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.31.</span> <span class="toc-text">React组件通信的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Router%E7%9A%84%E8%B7%AF%E7%94%B1%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.32.</span> <span class="toc-text">React Router的路由底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E4%B8%ADLink%E6%A0%87%E7%AD%BE%E5%92%8Ca%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.33.</span> <span class="toc-text">React中Link标签和a标签的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3props%E5%B5%8C%E5%A5%97%E8%BF%87%E6%B7%B1%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.34.</span> <span class="toc-text">如何解决props嵌套过深问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88useState%E8%A6%81%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.35.</span> <span class="toc-text">为什么useState要使用数组不是对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useEffect%E5%92%8CuseLayoutEffect%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.36.</span> <span class="toc-text">useEffect和useLayoutEffect的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8TS%E7%BB%93%E5%90%88React%E9%A1%B9%E7%9B%AE%E5%86%99%E8%BF%87%E5%90%97%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%83%BD%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">1.0.37.</span> <span class="toc-text">用TS结合React项目写过吗说一下都用在哪里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.38.</span> <span class="toc-text">React的设计思路是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0v-show"><span class="toc-number">1.0.39.</span> <span class="toc-text">React如何实现v-show</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.40.</span> <span class="toc-text">React遍历数据渲染的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C"><span class="toc-number">1.0.41.</span> <span class="toc-text">React错误边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E9%82%A3%E4%BA%9BReact-hooks%EF%BC%9F"><span class="toc-number">1.0.42.</span> <span class="toc-text">使用过那些React hooks？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3hooks"><span class="toc-number">1.0.42.1.</span> <span class="toc-text">数据相关hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useState"><span class="toc-number">1.0.42.1.1.</span> <span class="toc-text">useState</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useContext"><span class="toc-number">1.0.42.1.2.</span> <span class="toc-text">useContext</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useMemo"><span class="toc-number">1.0.42.1.3.</span> <span class="toc-text">useMemo</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useFef"><span class="toc-number">1.0.42.1.4.</span> <span class="toc-text">useFef</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useId"><span class="toc-number">1.0.42.1.5.</span> <span class="toc-text">useId</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%9B%B8%E5%85%B3hooks"><span class="toc-number">1.0.42.2.</span> <span class="toc-text">路由相关hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useLocation"><span class="toc-number">1.0.42.2.1.</span> <span class="toc-text">useLocation</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useNavigate"><span class="toc-number">1.0.42.2.2.</span> <span class="toc-text">useNavigate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useParams"><span class="toc-number">1.0.42.2.3.</span> <span class="toc-text">useParams</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E9%92%A9%E5%AD%90hooks"><span class="toc-number">1.0.42.3.</span> <span class="toc-text">状态相关钩子hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useEffect"><span class="toc-number">1.0.42.3.1.</span> <span class="toc-text">useEffect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useLayoutEffect"><span class="toc-number">1.0.42.3.2.</span> <span class="toc-text">useLayoutEffect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useCallback"><span class="toc-number">1.0.42.3.3.</span> <span class="toc-text">useCallback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#useReducer"><span class="toc-number">1.0.42.3.4.</span> <span class="toc-text">useReducer</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.0.42.4.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#useTransition"><span class="toc-number">1.0.42.4.1.</span> <span class="toc-text">useTransition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#createPortal"><span class="toc-number">1.0.42.4.2.</span> <span class="toc-text">createPortal</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/13/TechnicalArticles/Vue/13.vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="Vue3响应式原理"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue3响应式原理"/></a><div class="content"><a class="title" href="/2023/08/13/TechnicalArticles/Vue/13.vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" title="Vue3响应式原理">Vue3响应式原理</a><time datetime="2023-08-12T16:00:00.000Z" title="发表于 2023-08-13 00:00:00">2023-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/07/TechnicalArticles/Engineering/01%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E2%80%94Git%20Commit%20%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%8C%96/" title="前端工程化—Git Commit 提交规范化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端工程化—Git Commit 提交规范化"/></a><div class="content"><a class="title" href="/2023/08/07/TechnicalArticles/Engineering/01%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E2%80%94Git%20Commit%20%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%E5%8C%96/" title="前端工程化—Git Commit 提交规范化">前端工程化—Git Commit 提交规范化</a><time datetime="2023-08-06T16:00:00.000Z" title="发表于 2023-08-07 00:00:00">2023-08-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/07/TechnicalArticles/Engineering/02%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E2%80%94%E9%85%8D%E7%BD%AEEslint/" title="前端工程化—配置Eslint"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端工程化—配置Eslint"/></a><div class="content"><a class="title" href="/2023/08/07/TechnicalArticles/Engineering/02%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E2%80%94%E9%85%8D%E7%BD%AEEslint/" title="前端工程化—配置Eslint">前端工程化—配置Eslint</a><time datetime="2023-08-06T16:00:00.000Z" title="发表于 2023-08-07 00:00:00">2023-08-07</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.d5ab885cd02263c447edea13bd4eb06f?rik=io1mNZmII83GHw&amp;riu=http%3a%2f%2fimage.hnol.net%2fc%2f2016-10%2f05%2f20%2f201610052006512571-2127595.jpg&amp;ehk=sCZYotTH0JiRh80ttR%2bPGC95zALaETi8Hkj6WsAz85M%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><div id="footer-wrap"><div class="copyright">&copy;2023 By NobitaYuan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">此路甚是遥远，但也不可妄自菲薄.<p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://github.com/NobitaYuan"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.17/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script async src="/js/fps.js"></script><script src="/js/debounce.js"></script><script src="/js/sun_moon.js" async></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>